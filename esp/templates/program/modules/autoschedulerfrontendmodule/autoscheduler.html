{% extends "main.html" %}

{% block title %}Run the Automatic Scheduling Assistant{% endblock %}

{% block subsection_name %}Autoscheduler Options{% endblock %}

{% block content %}

<script>
var program_url_base = '{{ program.getUrlBase }}';
</script>
<script type="text/javascript" src="/media/scripts/program/modules/autoschedulerfrontend.js"></script>

<h1>Run the Automatic Scheduling Assistant</h1>

<p>A list of options is below. You should generally be able to leave them at
their defaults, but you can also play around with them if you prefer. If you
think the defaults should be changed, you can create or modify the appropriate
Tag; see the bottom of the page for more information. When you're ready, run
the autoscheduler, then save the results if you are satisfied.</p>

<form id="autoschedulerform" action="javascript:runAutoscheduler()" class="form-inline" method="POST">
<center>
    <h2>Search Options</h2>
<table width="100%" cellpadding="5">
{% for option_key, option_value in search.items %}
<tr>
	<th>{{ option_key }}</th>
	<td><input type="text" class="input-small" name="autoscheduler_search_{{ option_key }}" value="{{ option_value.0 }}" /></td>
	<td>{{ option_value.1 }}</td>
</tr>
{% endfor %}
</table>
    <h2>Constraint Options
    	<a href="javascript:toggleShowOptions('constraints')">
	<button type="button">Show/hide Constraint Options</button></a></h2>
    <div id="autoschedulerconstraintsdiv" style="display:none">
<p>Constraints control what the automatic scheduling assistant it allowed to
do. If a constraint is Required, you can't change it, but at least you know
it's there. Otherwise, you can turn it on or off as you like by setting it to
True or False. For information on ResourceCriteriaConstraint in particular,
see Resource Criterion Options below.</p>
<table width="100%" cellpadding="5">
{% for option_key, option_value in constraints.items %}
<tr>
	<th>{{ option_key }}</th>
	<td><input type="text" class="input-small" name="autoscheduler_constraints_{{ option_key }}" value="{{ option_value.0 }}" /></td>
	<td>{{ option_value.1 }}</td>
</tr>
{% endfor %}
</table>
    </div>
    <h2>Scoring Options
	<a href="javascript:toggleShowOptions('scorers')">
	<button type="button">Show/hide Scoring Options</button></a></h2>
    <div id="autoschedulerscorersdiv" style="display:none">
<p>Scorers control what the automatic scheduling assistant optimizes for when
it tries to find the best thing to do. They are aggregated together with
different weights; you can configure the weights below. The weight roughly
means how much, relatively speaking, the scorer matters for scheduling a
single section. For more information on ResourceCriteriaScorer, see Resource
Criterion Options below.</p>
<table width="100%" cellpadding="5">
{% for option_key, option_value in scorers.items %}
<tr>
	<th>{{ option_key }}</th>
	<td><input type="text" class="input-small" name="autoscheduler_scorers_{{ option_key }}" value="{{ option_value.0 }}" /></td>
	<td>{{ option_value.1 }}</td>
</tr>
{% endfor %}
</table>
    </div>

    <h2>Resource Criterion Options
	<a href="javascript:toggleShowOptions('resources')">
	<button type="button">Show/hide Resource Criterion
	    Options</button></a></h2>
    <div id="autoschedulerresourcesdiv" style="display:none">

<p>A Resource Criterion controls how the autoscheduler treats resources and
classrooms. You can control their weights below. If the weight is set to -1,
then it is a constraint, i.e. the automatic scheduling assistant is not allowed
to violate it. For example, if restrict_star_classrooms has weight -1, the
automatic scheduling assistant is not allowed to schedule any sections into
classrooms marked with a star; however, it does not necessarily prevent the
assistant from unscheduling a class already in a star classroom if you ask it
to. If the weight is nonnegative, it is used as a Scorer, as a part of the
ResourceCriteriaScorer. The weight is automatically scaled so that the
highest-weighted scorer criterion has weight 1. To add more resource criteria,
see the bottom of this page.</p>

<table width="100%" cellpadding="5">
{% for option_key, option_value in resources.items %}
<tr>
	<th>{{ option_key }}</th>
	<td><input type="text" class="input-small" name="autoscheduler_resources_{{ option_key }}" value="{{ option_value.0 }}" /></td>
	<td>{{ option_value.1 }}</td>
</tr>
{% endfor %}
</table>
    </div>

<table width="100%" cellpadding="5">
<tr>
    <td colspan="3"><button type="submit" class="btn btn-primary btn-large"
	    style="background-color:red; background-image: none;">Whee... Run the Automatic Scheduling Assistant!</button></td>
</tr>
<tr>
    <td colspan="3">
        <a href="javascript:saveAutoscheduler()"><button type="button" class="btn btn-success">Save room assignments</button></a>
        <a href="javascript:clearAutoscheduler()"><button type="button" class="btn btn-danger">Clear saved assignments</button></a>
    </td>
</tr>
</table>
</center>
</form>

<h1>Scheduling Information</h1>
<p>Scheduling information should appear below after you run the automatic scheduling tool.</p>

<div id="autoschedulerinfo"></div>

<h1>Configuration Help</h1>

<a href="javascript:toggleShowOptions('confighelp')">
<button type="button">Show/hide Configuration Help</button></a></h2>
<div id="autoschedulerconfighelpdiv" style="display:none">
<p>The Automatic Scheduling Assistant is configured with per-program
<a href="/admin/tagdict/tag/?content_type__model=program&object_id={{ program.id }}">
tags</a>. The tags may not already exist, in which case you need to create
them on the admin panel link above.</p>

<h2>Constraints</h2>
<p>To change the defaults on whether non-required constraints are on or off, use
the tag <code>autoscheduler_constraint_overrides</code>. The content of the
tag should be a JSON dict mapping from the name of the constraint to a boolean
(note that JSON booleans are "true" and "false", not "True" and "False"),
like:</p>
<pre><code>{
    "LunchConstraint": false
}
</code></pre>
<p>with different items separated by commas.</p>

<h2>Scoring</h2>
<p>To change the defaults on scorer weights, use the tag
<code>autoscheduler_scorer_weight_overrides</code>. The content of the tag is
once again a JSON dict, this time mapping from the name of the scorer to a
floating point number. For example:</p>
<pre><code>{
    "NumSectionsScorer": 200.0,
    "NumTeachersScorer": 80.0
}
</code></pre>

<h2>Resource Criteria</h2>

<p>Resource Criteria are essentially search terms on the resources a class
requests, the resources a classroom has, or the name of a classroom, which the
Automatic Scheduling Assistant is either required to or encouraged to satisfy
when it is moving classes around. To add a Resource Criterion, you need to
write a <strong>specification</strong>.</p>

<p>The syntax is as follows, where all caps denotes a variable and
brackets denote an optional argument:<?p>
<pre><code>if PREMISE then CONCLUSION</code></pre>

where PREMISE and CONCLUSION can be of the form
<pre><code>[not] section requests RESTYPE [with VALUE_REGEX]</code></pre>
or
<pre><code>[not] classroom has RESTYPE [with VALUE_REGEX]</code></pre>
or
<pre><code>[not] classroom matches NAME_REGEX</code></pre>
or
<pre><code>any section</code></pre>

<p>and where PREMISE and CONCLUSION must not both be section criteria or
both be classroom criteria. Regular expressions should follow Python's
<code>re</code> package syntax. See below for examples. Please note that
<strong>specifications, including resource types, are case sensitive and also
don't tolerate extra whitespace</strong>.</p>

<p>In general, the Resource Criteria tags map from the name of the Resource
Criterion (which can be whatever you want it to be) to the specification. You
can also turn off a Resource Criterion by setting the specification to "None"
(including quotes). Since regular expressions are confusing, you can
optionally include a comment in your tag. JSON doesn't support comments
natively, so to include a comment, create an entry with "_comment" in the
name, and the value is your comment. If a Resource Criterion has a comment
with a matching name, the comment is used for the help text on this page
instead of the specification string.</p>

<p>You should not have duplicate Resource Criterion names, not even between
constraints and scorers. I'm not entirely sure what happens if you do.</p>

<h3>Resource Criteria Constraints</h3>
<p>A ResourceCriteria Constraint creates a condition that the automatic
scheduling assistant will not violate, for example if you want to force it to
only schedule classes in main-group classrooms, or if you don't want to
schedule non-computer classes into computer clusters (or if you want to
schedule computer classes only into computer clusters, but I recommend you do
those by hand anyway because of OS and software considerations.)</p>

<p>To add or remove ResourceCriteria constraints, use the tag
<code>autoscheduler_resource_constraint_overrides</code>. The format should be
a JSON dict mapping from the name of the criterion (which can be whatever you
want) to the specification string, or "None" if you need to disable a default
constraint. Note that the scheduler will <em>not</em> break if you include a
Constraint that is violated by existing classes; the scheduler will simply not
introduce any new violations. (But just because an existing class violates a
constraint will not guarantee that the scheduler won't unschedule said
class.)</p>

<p>By default, the website comes with the "restrict_star_classrooms"
constraint, which means that no new classes will be scheduled in rooms marked
with a star in the name, e.g. *16-628.</p>

<p>Example:</p>
<pre><code>{
    "restrict_non_main":
        "if any section then classroom matches ^\\d+-\\d+$",
    "restrict_non_main_comment":
         "Only schedule into rooms with simple numeric names like 26-100"
}
</code></pre>

<h3>Resource Criteria Scorers</h3>

<p>A ResourceCriteria Scorer creates a condition that the assistant is
encouraged to satisfy. <strong>Note that the Automatic Scheduling Assistant
automatically comes with the ResourceMatchingScorer and
ResourceValueMatchingScorer</strong>, which are entirely separate, and
generically encourage the assistant to schedule classes into rooms which have
resources they want. You should use a ResourceCriteria Scorer if you
particularly want to weight one resource over the others (in which case you
can consider using a constraint instead) or there's a resource condition that
is more complex that aforementioned scorers don't understand.</p>

<p>To add or remove ResourceCriteria scorers, use the tag
<code>autoscheduler_resource_scoring_overrides</code>. The website comes with
no default ResourceCriteria Scorers. The format is a JSON dict mapping from
the name of the criterion to a pair containing the specification and a weight.
Note that Python's tuple syntax is <em>not</em> supported by JSON, so the pair
should be bracket-delimited, not parenthesis-delimited. Scorers are
re-weighted so that the highest-weight scorer has weight 1, which means that
(roughly speaking) adding more criteria shouldn't weaken existing ones.</p>

<p>Example:</p>
<pre><code>{
    "music_rooms":
        ["if section requests Classroom space with Music Room then classroom
matches .*(Music Room)", 1.0]
}
</code></pre>
</div>

{% include "program/modules/admincore/returnlink.html" %}

{% endblock %}
